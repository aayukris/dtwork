import React from "react";
import {
  Box,
  TextField,
  Grid,
  Button,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  Divider,
  CircularProgress,
  Modal,
  Typography
} from "@mui/material";
import { useFormik } from "formik";
import * as Yup from "yup";
import { addAddressAPI, editAddressAPI } from "@/modules";
import countries from "../helpers/countries.json";
import { useRouter } from "next/router";
import { getCookie } from "cookies-next";

import theme from "@/theme";
import Image from 'next/image';
import tick from "../../public/images/Tick.png"
import AutocompleteAddress from "./AutocompleteAddress";
import DetectCurrentLocation from "./DetectCurrentLocation";

//This is the address form that appears when user clicks add address/edit address

const AddressForm = (props: any) => {
  const { data, addAddres, phoneNum, phoneFHeader } = props;
  const [event, setEvent] = React.useState<any>();
  const [loader, setLoader] = React.useState<boolean>(false);
  const [open, setOpen] = React.useState<boolean>(false)
  const [postalData, setPostalData] = React.useState('')
  const [cityData, setCityData] = React.useState('')
  const [stateData, setStateData] = React.useState('')
  const [addressData, setAddressData] = React.useState('')



  const router = useRouter();
  //All filed validations
  const validation = useFormik({
    enableReinitialize: true,
    initialValues: {
      country: (event && !addAddres && event.country) || "India",
      fullName: (event && !addAddres && event.fullName) || "",
      company: (event && !addAddres && event.company) || "",
      address: (event && !addAddres && event.line && event.line.join(", ")) || addressData,
      apartment: (event && !addAddres && event.apartment) || "",
      pincode: (event && !addAddres && event.pincode) || "" || postalData,
      city: (event && !addAddres && event.city) || "" || cityData,
      state: (event && !addAddres && event.state) || "" || stateData,
      mobile: (event && (!addAddres ? event.mobile : event.mobileNo)) || phoneNum?.mobileNo || phoneFHeader,
    },
    validationSchema: Yup.object({
      country: Yup.string().required("This field is required"),
      fullName: Yup.string()
        .matches(
          ///^[a-zA-Z\s.]+$/,
          /^[^<]+$/,
          'Please provide correct input for name'
        )
        .required("This field is required"),
      company: Yup
        .string()
        .nullable()
        .optional()
        .matches(
          ///^[a-zA-Z0-9\s.,-]+$/,
          /^[^<]+$/,
          'Please provide correct input for company'
        ),
      address: Yup.string()
        .matches(
          ///^[a-zA-Z0-9\s.,-]+$/,
          /^[^<]+$/,
          //'Address can only contain letters, numbers, spaces, and common punctuation.'
          'Please provide correct input for address'
        )
        .required("This field is required"),
      apartment: Yup
        .string()
        .nullable()
        .optional()
        .matches(
          ///^[a-zA-Z0-9\s.,-]+$/,
          /^[^<]+$/,
          'Please provide correct input for apartment'
        ),
      pincode: Yup.string()
        .required("This filed is required")
        .min(6, "Enter valid PIN")
        .max(6, "Must be exactly 6 digits")
        .matches(
          /(?=.*?\d)^\$?(([1-9]\d{0,2}(,\d{3})*)|\d+)?(\.\d{1,2})?$/,
          "Pincode can only contain numbers"
        ),
      city: Yup.string()
        .matches(/^[a-zA-Z\s]*$/, 'City name can only contain letters')
        //.matches(/^\S(.*\S)?$/, 'City cannot have leading or trailing spaces')
        .required("This field is required"),
      state: Yup.string()
        .matches(/^[a-zA-Z\s]*$/, 'State name can only contain letters')
        //.matches(/^\S(.*\S)?$/, 'State cannot have leading or trailing spaces')
        .required("This field is required"),
      mobile: Yup.string()
        .required("This field is required")
        .min(10, "Phone number should be 10 digits without country code")
        .max(12, "Phone number should be 12 digits with country code")
        .matches(
          /(?=.*?\d)^\$?(([1-9]\d{0,2}(,\d{3})*)|\d+)?(\.\d{1,2})?$/,
          "This field will only accept numbers"
        ),
    }),

    onSubmit: async (values) => {
      setLoader(true);
      try {
        let body = {};
        //if user has chosen add-address then,
        if (addAddres) {
          body = {
            patientId: atob(getCookie("patientId")),
            country: values.country,
            fullName: values.fullName,
            company: values.company,
            line: values.address.split(","),
            apartment: values.apartment,
            pincode: values.pincode.toString(),
            city: values.city.trim(),
            state: values.state.trim(),
            mobile: values.mobile,
          };
        } else {
          //if user has chosen edit-address then, 
          //console.log(values, "values")
          body = {
            id: data.id,
            patientId: data.patientId,
            country: values.country,
            fullName: values.fullName,
            company: values.company,
            line: values.address.split(","),
            apartment: values.apartment,
            pincode: values.pincode.toString(),
            city: values.city,
            state: values.state,
            mobile: values.mobile,
          };
        }

        const res = addAddres
          ? await addAddressAPI(body)
          : await editAddressAPI(body);
        if (
          res?.message === "successully changed" ||
          res?.message === "success"
        ) {
          setLoader(false);
          setOpen(true)
        }
      } catch (error) {
        console.log(error);
        setLoader(false);
      }
    },
  });

  const handleOkClick = () => {
    setOpen(false)
    router.back()
  }
  //The incoming data prop is set as event state
  React.useEffect(() => {
    setEvent(data);
  }, [data]);


  const handleAddressChangeData = ({ postalCode, city, state, address }) => {
    validation.setFieldValue("address", address)
    validation.setFieldValue("pincode", postalCode)
    validation.setFieldValue("city", city)
    validation.setFieldValue("state", state)
    // setPostalData(postalCode)
    // setCityData(city)
    // setStateData(state)
    // setAddressData(address)
  }

  const handleBlur = (noOption, address) => {
    validation.setFieldValue("address", address)
  }


  return (
    <Grid container>
      {loader ? (
        <Box
          sx={{
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            height: "100vh",
            width: "100%",
          }}
        >
          <CircularProgress />
        </Box>
      ) : (
        <>
          <Grid item xs={12} sm={12} md={12} lg={12} xl={12}>
            <Box sx={{ pt: 1, pl: 1, pr: 1 }}>
              <form
                onSubmit={(e) => {
                  e.preventDefault();
                  validation.handleSubmit();
                  return false;
                }}
              >

                <DetectCurrentLocation onLocationDetected={handleAddressChangeData} />

                <FormControl fullWidth>
                  {/* <InputLabel id="demo-simple-select-label">
                    Country/Region<span style={{ color: "red" }}>*</span>
                  </InputLabel> */}
                  <TextField
                    name=""
                    label={
                      <span>
                        <span>Country/Region</span>
                        <span style={{ color: "red" }}>*</span>
                      </span>
                    }
                    variant="outlined"
                    fullWidth
                    value={"India"}
                    style={{ marginBottom: "1rem" }}
                    InputProps={{ readOnly: true, }}
                  />
                  {/* <Select
                    name="country"
                    labelId="demo-simple-select-label"
                    id="demo-simple-select"
                    value={validation.values.country || ""}
                    label="Country/Region*"
                    onChange={validation.handleChange}
                    sx={{ mb: 2 }}
                    MenuProps={{
                      PaperProps: {
                        style: {
                          transform: "translate3d(0rem, 2rem, 0rem)", // Adjust the translation as needed
                        },
                      },
                    }}
                  >
                    {countries.map((item) => (
                      <MenuItem key={item.code} value={item.name}>
                        {item.name}
                      </MenuItem>
                    ))}
                  </Select> */}
                </FormControl>
                <FormControl fullWidth>
                  <TextField
                    name="fullName"
                    label={
                      <span>
                        <span>Full Name</span>
                        <span style={{ color: "red" }}>*</span>
                      </span>
                    }
                    variant="outlined"
                    fullWidth
                    value={validation.values.fullName || ""}
                    onChange={validation.handleChange}
                    style={{ marginBottom: "1rem" }}
                    error={
                      Boolean(validation.errors.fullName) &&
                      Boolean(validation.touched.fullName)
                    }
                    helperText={
                      Boolean(validation.touched.fullName) &&
                      validation.errors.fullName
                    }
                  />
                </FormControl>
                <TextField
                  name="company"
                  label="Company (optional)"
                  variant="outlined"
                  fullWidth
                  value={validation.values.company || ""}
                  onChange={validation.handleChange}
                  style={{ marginBottom: "1rem" }}
                  error={
                    Boolean(validation.errors.company) &&
                    Boolean(validation.touched.company)
                  }
                  helperText={
                    Boolean(validation.touched.company) &&
                    validation.errors.company
                  }
                />



                <AutocompleteAddress onAddressChangeData={handleAddressChangeData}
                  // data={!addAddres ? data?.line?.join(', ') : ""}
                  isEdit={!addAddres}
                  value={validation.values.address || ""}
                  onChange={validation.handleChange}
                  error={
                    Boolean(validation.errors.address) &&
                    Boolean(validation.touched.address)
                  }
                  helperText={
                    Boolean(validation.touched.address) &&
                    validation.errors.address
                  }
                  onBlurParent={handleBlur}
                />

                {/* <TextField
                  name="address"
                  label={
                    <span>
                      <span>Address</span>
                      <span style={{ color: "red" }}>*</span>
                    </span>
                  }
                  variant="outlined"
                  fullWidth
                  value={validation.values.address || ""}
                  style={{ marginBottom: "1rem" }}
                  onChange={validation.handleChange}
                  error={
                    Boolean(validation.errors.address) &&
                    Boolean(validation.touched.address)
                  }
                  helperText={
                    Boolean(validation.touched.address) &&
                    validation.errors.address
                  }
                /> */}

                <TextField
                  name="apartment"
                  label="Apartment,suite,etc(optional)"
                  variant="outlined"
                  onChange={validation.handleChange}
                  fullWidth
                  value={validation.values.apartment || ""}
                  style={{ marginBottom: "1rem" }}
                  error={
                    Boolean(validation.errors.apartment) &&
                    Boolean(validation.touched.apartment)
                  }
                  helperText={
                    Boolean(validation.touched.apartment) &&
                    validation.errors.apartment
                  }
                />

                <TextField
                  name="pincode"
                  type="number"
                  inputProps={{ maxLength: 6 }}
                  label={
                    <span>
                      <span>Pincode</span>
                      <span style={{ color: "red" }}>*</span>
                    </span>
                  }
                  variant="outlined"
                  fullWidth
                  value={validation.values.pincode || ""}
                  onChange={validation.handleChange}
                  style={{ marginBottom: "1rem" }}
                  error={
                    Boolean(validation.errors.pincode) &&
                    Boolean(validation.touched.pincode)
                  }
                  helperText={
                    Boolean(validation.touched.pincode) &&
                    Boolean(validation.errors.pincode) &&
                    validation.errors.pincode
                  }
                />

                <TextField
                  name="city"
                  label={
                    <span>
                      <span>City</span>
                      <span style={{ color: "red" }}>*</span>
                    </span>
                  }
                  variant="outlined"
                  fullWidth
                  value={validation.values.city || ""}
                  onChange={validation.handleChange}
                  style={{ marginBottom: "1rem" }}
                  error={
                    Boolean(validation.errors.city) &&
                    Boolean(validation.touched.city)
                  }
                  helperText={
                    Boolean(validation.touched.city) &&
                    Boolean(validation.errors.city) &&
                    validation.errors.city
                  }
                />

                <TextField
                  name="state"
                  label={
                    <span>
                      <span>State</span>
                      <span style={{ color: "red" }}>*</span>
                    </span>
                  }
                  variant="outlined"
                  fullWidth
                  value={validation.values.state || ""}
                  onChange={validation.handleChange}
                  style={{ marginBottom: "1rem" }}
                  error={
                    Boolean(validation.errors.state) &&
                    Boolean(validation.touched.state)
                  }
                  helperText={
                    Boolean(validation.touched.state) &&
                    Boolean(validation.errors.state) &&
                    validation.errors.state
                  }
                />

                <TextField
                  name="mobile"
                  label={
                    <span>
                      <span>Mobile Number</span>
                      <span style={{ color: "red" }}>*</span>
                    </span>
                  }
                  variant="outlined"
                  fullWidth
                  value={validation.values.mobile || ""}
                  onChange={validation.handleChange}
                  style={{ marginBottom: "1rem" }}
                  error={
                    Boolean(validation.errors.mobile) &&
                    Boolean(validation.touched.mobile)
                  }
                  helperText={
                    Boolean(validation.touched.mobile) &&
                    Boolean(validation.errors.mobile) &&
                    validation.errors.mobile
                  }
                />
              </form>
            </Box>
          </Grid>
          <Grid item xs={12} sm={12} md={12} lg={12} xl={12}>
            <Divider />
            <Divider />
            <Box sx={{ float: "right", p: 1 }}>
              <Button
                variant="text"
                sx={{ mr: 1 }}
                onClick={() => router.back()}
              >
                CANCEL
              </Button>
              <Button
                variant="contained"
                type="submit"
                onClick={validation.submitForm}
              //onClick={handleSaveChanges}
              >
                SAVE CHANGES
              </Button>
            </Box>

            <Modal
              open={open}
              onClose={() => setOpen(false)}
              aria-labelledby="modal-modal-title"
              aria-describedby="modal-modal-description"
              sx={{ display: "flex", alignItems: "center", justifyContent: "center" }}
            >
              <Box sx={{
                backgroundColor: theme.palette.primary.light,
                borderRadius: "0.25rem",
                display: "flex",
                flexDirection: "column",
                rowGap: "1rem",
                justifyContent: "space-evenly",
                alignItems: "center",
                width: "80%",
                height: "30%",
                padding: "1rem"

              }}>
                <Image src={tick}
                  style={{ objectFit: "cover" }}
                  alt="tick mark"
                />

                <Box sx={{
                  display: "flex",
                  flexDirection: "column",
                  justifyContent: "space-around",
                  alignItems: "center",
                }}>
                  <Typography id="modal-modal-title" variant="h6" component="h2"
                    sx={{ fontWeight: 400 }}>
                    Your changes in address details have been saved successully.
                  </Typography>
                  <Box sx={{
                    width: "98%",
                    display: "flex",
                    justifyContent: "flex-end",
                    marginTop: "2.625rem",
                  }}>
                    <Typography
                      onClick={handleOkClick}
                      sx={{
                        color: theme.palette.primary.main,
                        cursor: "pointer",
                        ":hover": {
                          transform: "scale(1.1)",
                        },
                      }}
                    >
                      OK
                    </Typography>
                  </Box>
                </Box>

              </Box>
            </Modal>

          </Grid>
        </>
      )}
    </Grid>
  );
};

export default AddressForm;

import React from 'react';
import { TextField, CircularProgress, InputAdornment } from '@mui/material';
import RoomIcon from '@mui/icons-material/Room';
import { geocodeByAddress } from 'react-places-autocomplete';

const DetectCurrentLocation = ({ onLocationDetected }) => {
  const [isLocating, setIsLocating] = React.useState(false);
  const [displayAddress, setDisplayAddress] = React.useState("");

  const handleDetectLocation = () => {
    if (!navigator.geolocation) {
      console.error("Geolocation is not supported by this browser.");
      return;
    }

    setIsLocating(true);
    navigator.geolocation.getCurrentPosition(
      async (position) => {
        const { latitude, longitude } = position.coords;
        try {
          const results = await geocodeByAddress(`${latitude}, ${longitude}`);
          const selectedAddress = results[0].formatted_address;
          console.log("Address",selectedAddress)
          setDisplayAddress(selectedAddress);

          const addressComponents = results[0].address_components;

          const city = addressComponents.find(c => c.types.includes("locality"))?.long_name || "";
          const state = addressComponents.find(c => c.types.includes("administrative_area_level_1"))?.long_name || "";
          const postalCode = addressComponents.find(c => c.types.includes("postal_code"))?.long_name || "";

          onLocationDetected({
            address: selectedAddress,
            city,
            state,
            postalCode
          });
        } catch (error) {
          console.error("Error detecting location:", error);
        } finally {
          setIsLocating(false);
        }
      },
      (error) => {
        console.error("Geolocation error:", error);
        setIsLocating(false);
      }
    );
  };

  return (
    <>
      <TextField
        label="Detect Current Location"
        variant="outlined"
        fullWidth
        value={displayAddress}
        onClick={handleDetectLocation}
        InputProps={{
          readOnly: true,
          startAdornment: (
            <InputAdornment position="start">
              <RoomIcon color="action" />
            </InputAdornment>
          ),
          style: { cursor: 'pointer', backgroundColor: '#f5f5f5' }
        }}
        style={{ marginBottom: "1rem" }}
      />
      {isLocating && <CircularProgress size={24} style={{ marginBottom: "1rem" }} />}
    </>
  );
};

export default DetectCurrentLocation;


import theme from '@/theme';
import { TextField } from '@mui/material';
import React from 'react';
import PlacesAutocomplete, {
    geocodeByAddress,
    getLatLng,
} from "react-places-autocomplete";

const AutocompleteAddress = ({ onAddressChangeData, value, onChange, error, isEdit, helperText,onBlurParent }) => {
    const [address, setAddress] = React.useState(" ");
    const [flag, setFlag] = React.useState(0)
    const [isAddressSelected, setIsAddressSelected] = React.useState(false)
    const [noOption, setNoOption] = React.useState(false)
    const [hideSuggestion,setHideSuggestion]=React.useState(false)

    const handleSelect = async (selectedAddress: any) => {
        try {
            const results = await geocodeByAddress(selectedAddress);
            const latLng = await getLatLng(results[0]);

            setAddress(selectedAddress);
            setIsAddressSelected(true)
            setFlag(1)
            // console.log(results[0].address_components)

            // Accessing the city and state from the results
            const citySel = results[0].address_components.find(
                (component: any) => component.types.includes('locality')
            )?.long_name;

            const stateSel = results[0].address_components.find(
                (component: any) => component.types.includes('administrative_area_level_1')
            )?.long_name;

            // Accessing the postal code from the results
            let postalCode = results[0].address_components.find((component: any) =>
                component.types.includes("postal_code")
            );

            // If postal code is not available in the address components, perform reverse geocoding
            if (!postalCode) {
                const reverseGeocodeResults = await geocodeByCoordinates(latLng);
                postalCode = reverseGeocodeResults[0].address_components.find(
                    (component: any) => component.types.includes("postal_code")
                );
            }

            postalCode = postalCode ? postalCode.long_name : "Postal code not found";

            onAddressChangeData({
                postalCode: postalCode,
                city: citySel,
                state: stateSel,
                address:selectedAddress
            })

        } catch (error) {
            console.error("Error:", error);
        }
    };

    const geocodeByCoordinates = async ({ lat, lng }) => {
        return await geocodeByAddress(`${lat}, ${lng}`);
    };
    const handleInputChange = (input) => {
        setAddress(input);
        if(noOption === true){
            setAddress(input)
        }
        setHideSuggestion(false)
    };

    React.useEffect(() => {
        if (isEdit && flag == 0) {
            setAddress(value)
        }
    }, [value])

    const handleBlur = () => {
        if (!isAddressSelected) {
            setNoOption(true);
        }
        onBlurParent(noOption,address)
        setHideSuggestion(true)

    };

    return (
        <div>
            <PlacesAutocomplete
                value={address}
                // onChange={value ? onChange : handleInputChange}
                // value={address}               
                onChange={handleInputChange}
                onSelect={handleSelect}
            >
                {({ getInputProps, suggestions, getSuggestionItemProps, loading }) => (
                    <div>
                        {isEdit ? <TextField
                            name="address"
                            label={
                                <span>
                                    <span>Address</span>
                                    <span style={{ color: "red" }}>*</span>
                                </span>
                            }
                            variant="outlined"
                            fullWidth
                            style={{ marginBottom: "1rem" }}
                            {...getInputProps({
                                placeholder: "Address...",
                                className: "location-search-input",
                            })}
                            error={error}
                            helperText={helperText}
                            // value={value}
                            // onChange={onChange}
                            onBlur={handleBlur}
                        />
                            : <TextField
                                name="address"
                                label={
                                    <span>
                                        <span>Address</span>
                                        <span style={{ color: "red" }}>*</span>
                                    </span>
                                }
                                variant="outlined"
                                fullWidth
                                style={{ marginBottom: "1rem" }}
                                {...getInputProps({
                                    placeholder: "Address...",
                                    className: "location-search-input",
                                })}
                                error={error}
                                helperText={helperText}
                                onBlur={handleBlur}

                            />}
                        <div className="autocomplete-dropdown-container">
                            {loading && <div>Loading...</div>}
                            {!hideSuggestion && suggestions.map((suggestion) => {
                                const style = {
                                    backgroundColor: suggestion.active ? theme.palette.grey[200] : "#fff",
                                };
                                return (
                                    <div
                                        {...getSuggestionItemProps(suggestion, { style })}
                                        key={suggestion.placeId}
                                    >
                                        {suggestion.description}
                                    </div>
                                );
                            })}
                        </div>

                    </div>
                )}
            </PlacesAutocomplete>
        </div>
    );
};

export default AutocompleteAddress
