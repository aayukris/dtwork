import axios from "axios";
import jwtDecode from "jwt-decode";
import { getCookie, setCookie, deleteCookie } from "cookies-next";
import router from "next/router";

export const BASE_URL = `${process.env.NEXT_PUBLIC_BASE_URL}`;
export const REFRESH = "/api/auth/refresh";

// Refresh API call
export const refresh = async (body: { sessionId: string; refreshToken: string }) => {
  try {
    const res = await axios.post(`${BASE_URL}${REFRESH}`, body);
    return res.data;
  } catch (error: any) {
    return error.response;
  }
};

// Create Axios instance
const apiHelper = axios.create({
  baseURL: BASE_URL,
  timeout: 60000,
  withCredentials: true,
});

// Attach default headers
apiHelper.defaults.headers.common["Authorization"] = `Bearer ${getCookie("accessToken")}`;
apiHelper.defaults.headers.common["Sessionid"] = `${getCookie("sessionID")}`;
apiHelper.defaults.headers.common["Content-Security-Policy"] =
  "default-src 'self'; script-src 'self'; style-src 'self'; font-src 'self'; img-src 'self' data:; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; block-all-mixed-content; upgrade-insecure-requests; object-src 'none'; script-src-attr 'none'";
apiHelper.defaults.headers.common["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains; preload";
apiHelper.defaults.headers.common["X-Content-Type-Options"] = "nosniff";
apiHelper.defaults.headers.common["X-Frame-Options"] = "DENY";
apiHelper.defaults.headers.common["X-XSS-Protection"] = "1; mode=block";
apiHelper.defaults.headers.common["Referer-Policy"] = "strict-origin-when-cross-origin";

// Request interceptor
apiHelper.interceptors.request.use(
  config => {
    config.headers.Authorization = `Bearer ${getCookie("accessToken")}`;
    config.headers.Sessionid = getCookie("sessionID");
    return config;
  },
  error => Promise.reject(error)
);

// Response interceptor
apiHelper.interceptors.response.use(
  response => response,
  async error => {
    const originalRequest = error.config;

    if ((error.response?.status === 401 || error.response?.status === 403) && !originalRequest._retry) {
      originalRequest._retry = true;

      const sessionId = getCookie("sessionID") as string;
      const refreshToken = getCookie("refreshToken") as string;

      try {
        const refreshRes = await refresh({ sessionId, refreshToken });

        if (!refreshRes?.accessToken || !refreshRes?.refreshToken) {
          deleteCookie("accessToken");
          deleteCookie("refreshToken");
          deleteCookie("sessionID");
          router.push("/login");
          return Promise.reject(error);
        }
        console.log("success");
        setCookie("accessToken", refreshRes.accessToken);
        setCookie("refreshToken", refreshRes.refreshToken);
        originalRequest.headers.Authorization = `Bearer ${refreshRes.accessToken}`;

        return apiHelper(originalRequest); // Retry original request
      } catch (refreshError) {
        deleteCookie("accessToken");
        deleteCookie("refreshToken");
        deleteCookie("sessionID");
        router.push("/login");
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

// Proactive token refresh watcher
const scheduleTokenRefresh = () => {
  console.log("scheduler");
  const accessToken = getCookie("accessToken");
  const refreshToken = getCookie("refreshToken");
  const sessionId = getCookie("sessionID");

  if (!accessToken || !refreshToken || !sessionId) return;

  try {
    const decoded: any = jwtDecode(accessToken);
    const expiryTime = decoded.exp * 1000;
    const now = Date.now();
    const refreshTime = expiryTime - now - 60_000; // refresh 1 min before expiry
    console.log("Time:",refreshTime);

    if (refreshTime > 0) {
      setTimeout(async () => {
        try {
          const res = await refresh({ sessionId, refreshToken });

          if (res?.accessToken && res?.refreshToken) {
            setCookie("accessToken", res.accessToken);
            setCookie("refreshToken", res.refreshToken);
            console.log("Access token refreshed proactively.");
            scheduleTokenRefresh(); // Schedule next refresh
          } else {
            deleteCookie("accessToken");
            deleteCookie("refreshToken");
            deleteCookie("sessionID");
            // window.location.href = "/login";
                      router.push("/login")

          }
        } catch (err) {
          console.error("Proactive refresh failed:", err);
          deleteCookie("accessToken");
          deleteCookie("refreshToken");
          deleteCookie("sessionID");
          // window.location.href = "/login";
          router.push("/login")
        }
      }, refreshTime);
    }
  } catch (err) {
    console.error("Token decode error:", err);
  }
};

// Start proactive refresh watcher
scheduleTokenRefresh();

export default apiHelper;

import { useEffect } from "react";
import jwtDecode from "jwt-decode";
import { getCookie, setCookie, deleteCookie } from "cookies-next";
import router from "next/router";
import { refresh } from "../path/to/your/apiHelper"; // adjust path

const useTokenRefresh = () => {
  useEffect(() => {
    let refreshTimeout: NodeJS.Timeout;

    const scheduleRefresh = () => {
      const accessToken = getCookie("accessToken") as string;
      const refreshToken = getCookie("refreshToken") as string;
      const sessionId = getCookie("sessionID") as string;

      if (!accessToken || !refreshToken || !sessionId) {
        console.warn("Missing token/session info. Skipping proactive refresh.");
        return;
      }

      try {
        const decoded: any = jwtDecode(accessToken);
        const exp = Number(decoded.exp);
        const now = Date.now();
        const expiryTime = exp * 1000;
        const refreshTime = expiryTime - now - 60000; // 1 min before expiry

        console.log("Token expires at:", new Date(expiryTime).toLocaleString());
        console.log("Scheduled refresh after ms:", refreshTime);

        if (refreshTime > 0) {
          refreshTimeout = setTimeout(async () => {
            try {
              const res = await refresh({ sessionId, refreshToken });

              if (res?.accessToken && res?.refreshToken) {
                setCookie("accessToken", res.accessToken);
                setCookie("refreshToken", res.refreshToken);
                console.log("✅ Token proactively refreshed.");
                scheduleRefresh(); // schedule next refresh
              } else {
                throw new Error("Refresh response missing tokens.");
              }
            } catch (err) {
              console.error("❌ Proactive refresh failed:", err);
              logout();
            }
          }, refreshTime);
        } else {
          console.warn("Token is near expiry or invalid — skipping proactive scheduling.");
        }
      } catch (err) {
        console.error("Failed to decode token in scheduleRefresh:", err);
      }
    };

    const logout = () => {
      deleteCookie("accessToken");
      deleteCookie("refreshToken");
      deleteCookie("sessionID");
      router.push("/login");
    };

    // 🔁 Poll every 30s to check if token is expired/invalid
    const intervalCheck = setInterval(async () => {
      const accessToken = getCookie("accessToken") as string;
      const refreshToken = getCookie("refreshToken") as string;
      const sessionId = getCookie("sessionID") as string;

      if (!accessToken || !refreshToken || !sessionId) {
        console.warn("Interval check: Missing credentials.");
        return;
      }

      try {
        const decoded: any = jwtDecode(accessToken);
        const exp = Number(decoded.exp);
        const now = Date.now();

        if (isNaN(exp) || exp * 1000 < now) {
          console.warn("Interval check: Token expired or invalid, attempting refresh.");
          const res = await refresh({ sessionId, refreshToken });

          if (res?.accessToken && res?.refreshToken) {
            setCookie("accessToken", res.accessToken);
            setCookie("refreshToken", res.refreshToken);
            console.log("✅ Token refreshed by interval.");
            scheduleRefresh(); // reset scheduler with new token
          } else {
            throw new Error("Interval refresh response missing tokens.");
          }
        }
      } catch (err) {
        console.error("Interval check failed — token may be invalid. Logging out.");
        logout();
      }
    }, 30000); // every 30 seconds

    // Initial schedule
    scheduleRefresh();

    // 🔚 Cleanup on unmount
    return () => {
      clearTimeout(refreshTimeout);
      clearInterval(intervalCheck);
    };
  }, []);
};

export default useTokenRefresh;
